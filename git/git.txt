버전관리 용이
working directory : 파일이 만들어지는 곳
cache,staging area , index : commit 되기전의 파일들이 있는곳
repasitory : commit 된 파일 들이 있는 곳

파일을 저장할 때 이름이 달라도 내용이 같으면 같은 object를 가리킨다. >> 그러므로 중복을 제거한다.
같은 내용이 SHA1 hash라는 것을 거치면 같은 파일을 만든다. 
>> git add를 하면 git은 add한 파일의 내용을 보고 그 내용을 압축한다. 압축한 결과를 SHA1이라는 방법으로 hash를
통해서 값에 해당되는 디렉토리와 파일을 object라는 디렉토리에 만들고 index 파일에 파일의 내용은 
object값이라고 적어준다.

>> git commit 을 하면 수정되는 파일이 5개이다.
commit 도 파일의 내용처럼 objects라는 폴더에 들어간다. commit도 객체이다.
누가 commit을 했는지도 적혀진다.
tree = 각각의 파일의 정보가 적혔있는 것이다.
커밋을 또하면 parent라는 것이 생기는데 이것은 이전의 커밋의 정보를 가진다.
커밋을 한 시점의 정보를 tree라는 곳에 snap shot을 찍어서 넣어 놓는다.
 

objects >> blob >> 파일의 내용을 담는것
        >> tree >> blob에 대한 정보를 담는 것
        >> commit 

copy를 하면 같은 object를 가리킨다.


git status
>>index의 내용과 최근 커밋의 tree값이 같으면 commit할 것이 없다는 것을 알 수 있다.
>> vim을 해서 파일의 내용이 변경되면 index의 파일의 내용의 값과 파일이 만들어내는 내용의 값이 다르다면 
   파일이 수정되었다는 것을 알려준다.
>> 내용을 바꾸고 나서 add를 하면 index가 가리키는 내용과 파일이 만들어 내는 내용의 값이 같으면 commit대기 상태라는 
   것을 알려준다.
>> index의 내용과 최신 커밋의 tree가 가리키는 내용이 다르면 index에 add 되어서 commit대기 상태라는 것을 알려 준다.
>> commit을 하면 최신 커밋의 tree내용과 index의 내용과 파일의 내용이 같아져서 commit을 안해도 되는 상태라는 것을 알려 준다.

>>index와 tree의 관계
-
시나리오

당신은 마트 관리 프로그램 프로젝트에 참여 하였다.
한동안 일이 없어 빈둥대다가 일이 생겨 매우 기뻐하던 참이다.

 하지만 고객은 상당히 까다롭기로 유명한 진상 고객이다.
그래서 완성된 프로그램을 제안 하여도 여러번 수정을 해야할 가능성이 크다.

그래서 당신은 git을 이용해서 버전 관리를 하기로 마음먹었다.


당신이 받아든 제안서에는 다음과 같은 조건들이 있었다

1차 제안).
1) 프로그램은 'angvik_mart'라는 폴더에 담겨야 한다
2) 마트 업무는 재고 관리, 재무 관리, 인사 관리로 총 3가지 분류로 나뉜다
 
2차 제안)
1) 고객이 행사 관리 업무가 새로 생겼다고 말하며 프로그램에 추가를 요청한다
2) 고객이 '황진국'이라는 새로운 직원이 입사하여서 인사 관리 명단에 등록을 요구하였다.

3차 제안)
1) 고객이 처음 받았던 프로그램과 달라진게 뭐냐고 화를 내며 개선한 사항을 보여달라고 요구해왔다.

4차 제안)
1) 고객이 변심하여 2차 제안 받았던 프로그램으로 다시 바꿔달라고 요구하였다

번외)
당신은 책임있는 개발자다. 당신이 관리하는 프로그램에 당신의 이름과, 이메일을 남겨둬야 한다.